// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hokuyo.proto

#ifndef PROTOBUF_hokuyo_2eproto__INCLUDED
#define PROTOBUF_hokuyo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "drivermsg.pb.h"
// @@protoc_insertion_point(includes)

namespace amber {
namespace hokuyo_proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_hokuyo_2eproto();
void protobuf_AssignDesc_hokuyo_2eproto();
void protobuf_ShutdownFile_hokuyo_2eproto();

class Version;
class Specs;
class State;
class Scan;

// ===================================================================

class Version : public ::google::protobuf::Message {
 public:
  Version();
  virtual ~Version();
  
  Version(const Version& from);
  
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();
  
  void Swap(Version* other);
  
  // implements Message ----------------------------------------------
  
  Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string response = 1;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const char* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // optional string vendor = 2;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 2;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  
  // optional string product = 3;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 3;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  
  // optional string firmware = 4;
  inline bool has_firmware() const;
  inline void clear_firmware();
  static const int kFirmwareFieldNumber = 4;
  inline const ::std::string& firmware() const;
  inline void set_firmware(const ::std::string& value);
  inline void set_firmware(const char* value);
  inline void set_firmware(const char* value, size_t size);
  inline ::std::string* mutable_firmware();
  inline ::std::string* release_firmware();
  
  // optional string protocol = 5;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 5;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  
  // optional string serial = 6;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 6;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  
  // @@protoc_insertion_point(class_scope:amber.hokuyo_proto.Version)
 private:
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_firmware();
  inline void clear_has_firmware();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_serial();
  inline void clear_has_serial();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_;
  ::std::string* vendor_;
  ::std::string* product_;
  ::std::string* firmware_;
  ::std::string* protocol_;
  ::std::string* serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_hokuyo_2eproto();
  friend void protobuf_AssignDesc_hokuyo_2eproto();
  friend void protobuf_ShutdownFile_hokuyo_2eproto();
  
  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class Specs : public ::google::protobuf::Message {
 public:
  Specs();
  virtual ~Specs();
  
  Specs(const Specs& from);
  
  inline Specs& operator=(const Specs& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Specs& default_instance();
  
  void Swap(Specs* other);
  
  // implements Message ----------------------------------------------
  
  Specs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Specs& from);
  void MergeFrom(const Specs& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string response = 1;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const char* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // optional string model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  
  // optional uint32 distance_minimum = 3;
  inline bool has_distance_minimum() const;
  inline void clear_distance_minimum();
  static const int kDistanceMinimumFieldNumber = 3;
  inline ::google::protobuf::uint32 distance_minimum() const;
  inline void set_distance_minimum(::google::protobuf::uint32 value);
  
  // optional uint32 distance_maximum = 4;
  inline bool has_distance_maximum() const;
  inline void clear_distance_maximum();
  static const int kDistanceMaximumFieldNumber = 4;
  inline ::google::protobuf::uint32 distance_maximum() const;
  inline void set_distance_maximum(::google::protobuf::uint32 value);
  
  // optional uint32 area_resolution = 5;
  inline bool has_area_resolution() const;
  inline void clear_area_resolution();
  static const int kAreaResolutionFieldNumber = 5;
  inline ::google::protobuf::uint32 area_resolution() const;
  inline void set_area_resolution(::google::protobuf::uint32 value);
  
  // optional uint32 area_minimum = 6;
  inline bool has_area_minimum() const;
  inline void clear_area_minimum();
  static const int kAreaMinimumFieldNumber = 6;
  inline ::google::protobuf::uint32 area_minimum() const;
  inline void set_area_minimum(::google::protobuf::uint32 value);
  
  // optional uint32 area_maximum = 7;
  inline bool has_area_maximum() const;
  inline void clear_area_maximum();
  static const int kAreaMaximumFieldNumber = 7;
  inline ::google::protobuf::uint32 area_maximum() const;
  inline void set_area_maximum(::google::protobuf::uint32 value);
  
  // optional uint32 area_front = 8;
  inline bool has_area_front() const;
  inline void clear_area_front();
  static const int kAreaFrontFieldNumber = 8;
  inline ::google::protobuf::uint32 area_front() const;
  inline void set_area_front(::google::protobuf::uint32 value);
  
  // optional uint32 motor_speed = 9;
  inline bool has_motor_speed() const;
  inline void clear_motor_speed();
  static const int kMotorSpeedFieldNumber = 9;
  inline ::google::protobuf::uint32 motor_speed() const;
  inline void set_motor_speed(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:amber.hokuyo_proto.Specs)
 private:
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_distance_minimum();
  inline void clear_has_distance_minimum();
  inline void set_has_distance_maximum();
  inline void clear_has_distance_maximum();
  inline void set_has_area_resolution();
  inline void clear_has_area_resolution();
  inline void set_has_area_minimum();
  inline void clear_has_area_minimum();
  inline void set_has_area_maximum();
  inline void clear_has_area_maximum();
  inline void set_has_area_front();
  inline void clear_has_area_front();
  inline void set_has_motor_speed();
  inline void clear_has_motor_speed();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_;
  ::std::string* model_;
  ::google::protobuf::uint32 distance_minimum_;
  ::google::protobuf::uint32 distance_maximum_;
  ::google::protobuf::uint32 area_resolution_;
  ::google::protobuf::uint32 area_minimum_;
  ::google::protobuf::uint32 area_maximum_;
  ::google::protobuf::uint32 area_front_;
  ::google::protobuf::uint32 motor_speed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_hokuyo_2eproto();
  friend void protobuf_AssignDesc_hokuyo_2eproto();
  friend void protobuf_ShutdownFile_hokuyo_2eproto();
  
  void InitAsDefaultInstance();
  static Specs* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();
  
  State(const State& from);
  
  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();
  
  void Swap(State* other);
  
  // implements Message ----------------------------------------------
  
  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string response = 1;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 1;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const char* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // optional string model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  
  // optional bool laser = 3;
  inline bool has_laser() const;
  inline void clear_laser();
  static const int kLaserFieldNumber = 3;
  inline bool laser() const;
  inline void set_laser(bool value);
  
  // optional string motor_speed = 4;
  inline bool has_motor_speed() const;
  inline void clear_motor_speed();
  static const int kMotorSpeedFieldNumber = 4;
  inline const ::std::string& motor_speed() const;
  inline void set_motor_speed(const ::std::string& value);
  inline void set_motor_speed(const char* value);
  inline void set_motor_speed(const char* value, size_t size);
  inline ::std::string* mutable_motor_speed();
  inline ::std::string* release_motor_speed();
  
  // optional string measure_mode = 5;
  inline bool has_measure_mode() const;
  inline void clear_measure_mode();
  static const int kMeasureModeFieldNumber = 5;
  inline const ::std::string& measure_mode() const;
  inline void set_measure_mode(const ::std::string& value);
  inline void set_measure_mode(const char* value);
  inline void set_measure_mode(const char* value, size_t size);
  inline ::std::string* mutable_measure_mode();
  inline ::std::string* release_measure_mode();
  
  // optional string bit_rate = 6;
  inline bool has_bit_rate() const;
  inline void clear_bit_rate();
  static const int kBitRateFieldNumber = 6;
  inline const ::std::string& bit_rate() const;
  inline void set_bit_rate(const ::std::string& value);
  inline void set_bit_rate(const char* value);
  inline void set_bit_rate(const char* value, size_t size);
  inline ::std::string* mutable_bit_rate();
  inline ::std::string* release_bit_rate();
  
  // optional string time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  
  // optional string diagnostic = 8;
  inline bool has_diagnostic() const;
  inline void clear_diagnostic();
  static const int kDiagnosticFieldNumber = 8;
  inline const ::std::string& diagnostic() const;
  inline void set_diagnostic(const ::std::string& value);
  inline void set_diagnostic(const char* value);
  inline void set_diagnostic(const char* value, size_t size);
  inline ::std::string* mutable_diagnostic();
  inline ::std::string* release_diagnostic();
  
  // @@protoc_insertion_point(class_scope:amber.hokuyo_proto.State)
 private:
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_laser();
  inline void clear_has_laser();
  inline void set_has_motor_speed();
  inline void clear_has_motor_speed();
  inline void set_has_measure_mode();
  inline void clear_has_measure_mode();
  inline void set_has_bit_rate();
  inline void clear_has_bit_rate();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_diagnostic();
  inline void clear_has_diagnostic();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_;
  ::std::string* model_;
  ::std::string* motor_speed_;
  ::std::string* measure_mode_;
  ::std::string* bit_rate_;
  ::std::string* time_;
  ::std::string* diagnostic_;
  bool laser_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_hokuyo_2eproto();
  friend void protobuf_AssignDesc_hokuyo_2eproto();
  friend void protobuf_ShutdownFile_hokuyo_2eproto();
  
  void InitAsDefaultInstance();
  static State* default_instance_;
};
// -------------------------------------------------------------------

class Scan : public ::google::protobuf::Message {
 public:
  Scan();
  virtual ~Scan();
  
  Scan(const Scan& from);
  
  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scan& default_instance();
  
  void Swap(Scan* other);
  
  // implements Message ----------------------------------------------
  
  Scan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated double angles = 1 [packed = true];
  inline int angles_size() const;
  inline void clear_angles();
  static const int kAnglesFieldNumber = 1;
  inline double angles(int index) const;
  inline void set_angles(int index, double value);
  inline void add_angles(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      angles() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_angles();
  
  // repeated int32 distances = 2 [packed = true];
  inline int distances_size() const;
  inline void clear_distances();
  static const int kDistancesFieldNumber = 2;
  inline ::google::protobuf::int32 distances(int index) const;
  inline void set_distances(int index, ::google::protobuf::int32 value);
  inline void add_distances(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      distances() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_distances();
  
  // @@protoc_insertion_point(class_scope:amber.hokuyo_proto.Scan)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< double > angles_;
  mutable int _angles_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > distances_;
  mutable int _distances_cached_byte_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_hokuyo_2eproto();
  friend void protobuf_AssignDesc_hokuyo_2eproto();
  friend void protobuf_ShutdownFile_hokuyo_2eproto();
  
  void InitAsDefaultInstance();
  static Scan* default_instance_;
};
// ===================================================================

static const int kGetVersionInfoFieldNumber = 41;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  get_version_info;
static const int kGetSensorStateFieldNumber = 42;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  get_sensor_state;
static const int kGetSensorSpecsFieldNumber = 43;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  get_sensor_specs;
static const int kGetSingleScanFieldNumber = 44;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  get_single_scan;
static const int kVersionFieldNumber = 45;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::MessageTypeTraits< ::amber::hokuyo_proto::Version >, 11, false >
  version;
static const int kSpecsFieldNumber = 46;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::MessageTypeTraits< ::amber::hokuyo_proto::Specs >, 11, false >
  specs;
static const int kStateFieldNumber = 47;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::MessageTypeTraits< ::amber::hokuyo_proto::State >, 11, false >
  state;
static const int kScanFieldNumber = 48;
extern ::google::protobuf::internal::ExtensionIdentifier< ::amber::DriverMsg,
    ::google::protobuf::internal::MessageTypeTraits< ::amber::hokuyo_proto::Scan >, 11, false >
  scan;

// ===================================================================

// Version

// optional string response = 1;
inline bool Version::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& Version::response() const {
  return *response_;
}
inline void Version::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void Version::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void Version::set_response(const char* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* Version::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string vendor = 2;
inline bool Version::has_vendor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::set_has_vendor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Version::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Version::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Version::vendor() const {
  return *vendor_;
}
inline void Version::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Version::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Version::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* Version::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string product = 3;
inline bool Version::has_product() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::set_has_product() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Version::clear_has_product() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Version::clear_product() {
  if (product_ != &::google::protobuf::internal::kEmptyString) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& Version::product() const {
  return *product_;
}
inline void Version::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void Version::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void Version::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    product_ = new ::std::string;
  }
  return product_;
}
inline ::std::string* Version::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string firmware = 4;
inline bool Version::has_firmware() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Version::set_has_firmware() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Version::clear_has_firmware() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Version::clear_firmware() {
  if (firmware_ != &::google::protobuf::internal::kEmptyString) {
    firmware_->clear();
  }
  clear_has_firmware();
}
inline const ::std::string& Version::firmware() const {
  return *firmware_;
}
inline void Version::set_firmware(const ::std::string& value) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::kEmptyString) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(value);
}
inline void Version::set_firmware(const char* value) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::kEmptyString) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(value);
}
inline void Version::set_firmware(const char* value, size_t size) {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::kEmptyString) {
    firmware_ = new ::std::string;
  }
  firmware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_firmware() {
  set_has_firmware();
  if (firmware_ == &::google::protobuf::internal::kEmptyString) {
    firmware_ = new ::std::string;
  }
  return firmware_;
}
inline ::std::string* Version::release_firmware() {
  clear_has_firmware();
  if (firmware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firmware_;
    firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string protocol = 5;
inline bool Version::has_protocol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Version::set_has_protocol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Version::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Version::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& Version::protocol() const {
  return *protocol_;
}
inline void Version::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Version::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void Version::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* Version::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string serial = 6;
inline bool Version::has_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Version::set_has_serial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Version::clear_has_serial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Version::clear_serial() {
  if (serial_ != &::google::protobuf::internal::kEmptyString) {
    serial_->clear();
  }
  clear_has_serial();
}
inline const ::std::string& Version::serial() const {
  return *serial_;
}
inline void Version::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void Version::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void Version::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Version::mutable_serial() {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  return serial_;
}
inline ::std::string* Version::release_serial() {
  clear_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Specs

// optional string response = 1;
inline bool Specs::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Specs::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Specs::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Specs::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& Specs::response() const {
  return *response_;
}
inline void Specs::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void Specs::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void Specs::set_response(const char* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Specs::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* Specs::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string model = 2;
inline bool Specs::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Specs::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Specs::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Specs::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Specs::model() const {
  return *model_;
}
inline void Specs::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Specs::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Specs::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Specs::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* Specs::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 distance_minimum = 3;
inline bool Specs::has_distance_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Specs::set_has_distance_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Specs::clear_has_distance_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Specs::clear_distance_minimum() {
  distance_minimum_ = 0u;
  clear_has_distance_minimum();
}
inline ::google::protobuf::uint32 Specs::distance_minimum() const {
  return distance_minimum_;
}
inline void Specs::set_distance_minimum(::google::protobuf::uint32 value) {
  set_has_distance_minimum();
  distance_minimum_ = value;
}

// optional uint32 distance_maximum = 4;
inline bool Specs::has_distance_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Specs::set_has_distance_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Specs::clear_has_distance_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Specs::clear_distance_maximum() {
  distance_maximum_ = 0u;
  clear_has_distance_maximum();
}
inline ::google::protobuf::uint32 Specs::distance_maximum() const {
  return distance_maximum_;
}
inline void Specs::set_distance_maximum(::google::protobuf::uint32 value) {
  set_has_distance_maximum();
  distance_maximum_ = value;
}

// optional uint32 area_resolution = 5;
inline bool Specs::has_area_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Specs::set_has_area_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Specs::clear_has_area_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Specs::clear_area_resolution() {
  area_resolution_ = 0u;
  clear_has_area_resolution();
}
inline ::google::protobuf::uint32 Specs::area_resolution() const {
  return area_resolution_;
}
inline void Specs::set_area_resolution(::google::protobuf::uint32 value) {
  set_has_area_resolution();
  area_resolution_ = value;
}

// optional uint32 area_minimum = 6;
inline bool Specs::has_area_minimum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Specs::set_has_area_minimum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Specs::clear_has_area_minimum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Specs::clear_area_minimum() {
  area_minimum_ = 0u;
  clear_has_area_minimum();
}
inline ::google::protobuf::uint32 Specs::area_minimum() const {
  return area_minimum_;
}
inline void Specs::set_area_minimum(::google::protobuf::uint32 value) {
  set_has_area_minimum();
  area_minimum_ = value;
}

// optional uint32 area_maximum = 7;
inline bool Specs::has_area_maximum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Specs::set_has_area_maximum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Specs::clear_has_area_maximum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Specs::clear_area_maximum() {
  area_maximum_ = 0u;
  clear_has_area_maximum();
}
inline ::google::protobuf::uint32 Specs::area_maximum() const {
  return area_maximum_;
}
inline void Specs::set_area_maximum(::google::protobuf::uint32 value) {
  set_has_area_maximum();
  area_maximum_ = value;
}

// optional uint32 area_front = 8;
inline bool Specs::has_area_front() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Specs::set_has_area_front() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Specs::clear_has_area_front() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Specs::clear_area_front() {
  area_front_ = 0u;
  clear_has_area_front();
}
inline ::google::protobuf::uint32 Specs::area_front() const {
  return area_front_;
}
inline void Specs::set_area_front(::google::protobuf::uint32 value) {
  set_has_area_front();
  area_front_ = value;
}

// optional uint32 motor_speed = 9;
inline bool Specs::has_motor_speed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Specs::set_has_motor_speed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Specs::clear_has_motor_speed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Specs::clear_motor_speed() {
  motor_speed_ = 0u;
  clear_has_motor_speed();
}
inline ::google::protobuf::uint32 Specs::motor_speed() const {
  return motor_speed_;
}
inline void Specs::set_motor_speed(::google::protobuf::uint32 value) {
  set_has_motor_speed();
  motor_speed_ = value;
}

// -------------------------------------------------------------------

// State

// optional string response = 1;
inline bool State::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& State::response() const {
  return *response_;
}
inline void State::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void State::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void State::set_response(const char* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* State::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string model = 2;
inline bool State::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& State::model() const {
  return *model_;
}
inline void State::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void State::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void State::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* State::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool laser = 3;
inline bool State::has_laser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_laser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_laser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_laser() {
  laser_ = false;
  clear_has_laser();
}
inline bool State::laser() const {
  return laser_;
}
inline void State::set_laser(bool value) {
  set_has_laser();
  laser_ = value;
}

// optional string motor_speed = 4;
inline bool State::has_motor_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_motor_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_motor_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_motor_speed() {
  if (motor_speed_ != &::google::protobuf::internal::kEmptyString) {
    motor_speed_->clear();
  }
  clear_has_motor_speed();
}
inline const ::std::string& State::motor_speed() const {
  return *motor_speed_;
}
inline void State::set_motor_speed(const ::std::string& value) {
  set_has_motor_speed();
  if (motor_speed_ == &::google::protobuf::internal::kEmptyString) {
    motor_speed_ = new ::std::string;
  }
  motor_speed_->assign(value);
}
inline void State::set_motor_speed(const char* value) {
  set_has_motor_speed();
  if (motor_speed_ == &::google::protobuf::internal::kEmptyString) {
    motor_speed_ = new ::std::string;
  }
  motor_speed_->assign(value);
}
inline void State::set_motor_speed(const char* value, size_t size) {
  set_has_motor_speed();
  if (motor_speed_ == &::google::protobuf::internal::kEmptyString) {
    motor_speed_ = new ::std::string;
  }
  motor_speed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_motor_speed() {
  set_has_motor_speed();
  if (motor_speed_ == &::google::protobuf::internal::kEmptyString) {
    motor_speed_ = new ::std::string;
  }
  return motor_speed_;
}
inline ::std::string* State::release_motor_speed() {
  clear_has_motor_speed();
  if (motor_speed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = motor_speed_;
    motor_speed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string measure_mode = 5;
inline bool State::has_measure_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_measure_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_measure_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_measure_mode() {
  if (measure_mode_ != &::google::protobuf::internal::kEmptyString) {
    measure_mode_->clear();
  }
  clear_has_measure_mode();
}
inline const ::std::string& State::measure_mode() const {
  return *measure_mode_;
}
inline void State::set_measure_mode(const ::std::string& value) {
  set_has_measure_mode();
  if (measure_mode_ == &::google::protobuf::internal::kEmptyString) {
    measure_mode_ = new ::std::string;
  }
  measure_mode_->assign(value);
}
inline void State::set_measure_mode(const char* value) {
  set_has_measure_mode();
  if (measure_mode_ == &::google::protobuf::internal::kEmptyString) {
    measure_mode_ = new ::std::string;
  }
  measure_mode_->assign(value);
}
inline void State::set_measure_mode(const char* value, size_t size) {
  set_has_measure_mode();
  if (measure_mode_ == &::google::protobuf::internal::kEmptyString) {
    measure_mode_ = new ::std::string;
  }
  measure_mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_measure_mode() {
  set_has_measure_mode();
  if (measure_mode_ == &::google::protobuf::internal::kEmptyString) {
    measure_mode_ = new ::std::string;
  }
  return measure_mode_;
}
inline ::std::string* State::release_measure_mode() {
  clear_has_measure_mode();
  if (measure_mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = measure_mode_;
    measure_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string bit_rate = 6;
inline bool State::has_bit_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_bit_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_bit_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void State::clear_bit_rate() {
  if (bit_rate_ != &::google::protobuf::internal::kEmptyString) {
    bit_rate_->clear();
  }
  clear_has_bit_rate();
}
inline const ::std::string& State::bit_rate() const {
  return *bit_rate_;
}
inline void State::set_bit_rate(const ::std::string& value) {
  set_has_bit_rate();
  if (bit_rate_ == &::google::protobuf::internal::kEmptyString) {
    bit_rate_ = new ::std::string;
  }
  bit_rate_->assign(value);
}
inline void State::set_bit_rate(const char* value) {
  set_has_bit_rate();
  if (bit_rate_ == &::google::protobuf::internal::kEmptyString) {
    bit_rate_ = new ::std::string;
  }
  bit_rate_->assign(value);
}
inline void State::set_bit_rate(const char* value, size_t size) {
  set_has_bit_rate();
  if (bit_rate_ == &::google::protobuf::internal::kEmptyString) {
    bit_rate_ = new ::std::string;
  }
  bit_rate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_bit_rate() {
  set_has_bit_rate();
  if (bit_rate_ == &::google::protobuf::internal::kEmptyString) {
    bit_rate_ = new ::std::string;
  }
  return bit_rate_;
}
inline ::std::string* State::release_bit_rate() {
  clear_has_bit_rate();
  if (bit_rate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bit_rate_;
    bit_rate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string time = 7;
inline bool State::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void State::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void State::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void State::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& State::time() const {
  return *time_;
}
inline void State::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void State::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void State::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* State::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string diagnostic = 8;
inline bool State::has_diagnostic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void State::set_has_diagnostic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void State::clear_has_diagnostic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void State::clear_diagnostic() {
  if (diagnostic_ != &::google::protobuf::internal::kEmptyString) {
    diagnostic_->clear();
  }
  clear_has_diagnostic();
}
inline const ::std::string& State::diagnostic() const {
  return *diagnostic_;
}
inline void State::set_diagnostic(const ::std::string& value) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(value);
}
inline void State::set_diagnostic(const char* value) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(value);
}
inline void State::set_diagnostic(const char* value, size_t size) {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  diagnostic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* State::mutable_diagnostic() {
  set_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    diagnostic_ = new ::std::string;
  }
  return diagnostic_;
}
inline ::std::string* State::release_diagnostic() {
  clear_has_diagnostic();
  if (diagnostic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diagnostic_;
    diagnostic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Scan

// repeated double angles = 1 [packed = true];
inline int Scan::angles_size() const {
  return angles_.size();
}
inline void Scan::clear_angles() {
  angles_.Clear();
}
inline double Scan::angles(int index) const {
  return angles_.Get(index);
}
inline void Scan::set_angles(int index, double value) {
  angles_.Set(index, value);
}
inline void Scan::add_angles(double value) {
  angles_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Scan::angles() const {
  return angles_;
}
inline ::google::protobuf::RepeatedField< double >*
Scan::mutable_angles() {
  return &angles_;
}

// repeated int32 distances = 2 [packed = true];
inline int Scan::distances_size() const {
  return distances_.size();
}
inline void Scan::clear_distances() {
  distances_.Clear();
}
inline ::google::protobuf::int32 Scan::distances(int index) const {
  return distances_.Get(index);
}
inline void Scan::set_distances(int index, ::google::protobuf::int32 value) {
  distances_.Set(index, value);
}
inline void Scan::add_distances(::google::protobuf::int32 value) {
  distances_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Scan::distances() const {
  return distances_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Scan::mutable_distances() {
  return &distances_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hokuyo_proto
}  // namespace amber

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hokuyo_2eproto__INCLUDED
